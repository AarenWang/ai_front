<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>爱因斯坦之谜求解演示</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }

        .puzzle-container {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 10px;
            margin: 20px 0;
        }

        .house {
            background-color: white;
            border: 2px solid #ccc;
            border-radius: 8px;
            padding: 15px;
            transition: all 0.3s ease;
        }

        .house.highlight {
            background-color: #e3f2fd;
            border-color: #2196f3;
            box-shadow: 0 0 10px rgba(33, 150, 243, 0.3);
        }

        .clue-list {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
        }

        .clue {
            margin: 10px 0;
            padding: 10px;
            border-left: 4px solid #2196f3;
            background-color: #f8f9fa;
            opacity: 0.7;
            transition: opacity 0.3s ease;
        }

        .clue.active {
            opacity: 1;
            background-color: #e3f2fd;
        }

        .controls {
            display: flex;
            gap: 10px;
            margin: 20px 0;
        }

        button {
            padding: 10px 20px;
            font-size: 16px;
            border: none;
            border-radius: 4px;
            background-color: #2196f3;
            color: white;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        button:hover {
            background-color: #1976d2;
        }

        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        .property {
            margin: 5px 0;
            padding: 5px;
            border-radius: 4px;
        }

        .property.confirmed {
            background-color: #c8e6c9;
        }

        .explanation {
            margin-top: 10px;
            font-style: italic;
            color: #666;
        }

        .property select {
            width: 100%;
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 14px;
            background-color: white;
        }

        .property.confirmed select {
            background-color: #c8e6c9;
            pointer-events: none;  /* 已确认的选项禁止修改 */
        }

        .property label {
            display: block;
            margin-bottom: 3px;
            font-weight: bold;
            color: #666;
        }

        /* 添加新的样式 */
        .house.valid {
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
        }

        .house.invalid {
            box-shadow: 0 0 10px rgba(244, 67, 54, 0.5);
        }

        .hint-button {
            font-size: 12px;
            padding: 3px 8px;
            margin-left: 5px;
            background-color: #ff9800;
        }

        .progress-bar {
            width: 100%;
            height: 10px;
            background-color: #eee;
            border-radius: 5px;
            margin: 10px 0;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background-color: #4CAF50;
            width: 0%;
            transition: width 0.3s ease;
        }

        .status-message {
            text-align: center;
            margin: 10px 0;
            padding: 10px;
            border-radius: 4px;
            display: none;
        }

        .status-message.success {
            background-color: #c8e6c9;
            color: #2e7d32;
            display: block;
        }

        .status-message.error {
            background-color: #ffcdd2;
            color: #c62828;
            display: block;
        }

        /* 添加新的布局样式 */
        .main-container {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }

        .puzzle-section {
            flex: 1;
            min-width: 0;  /* 防止flex子项溢出 */
        }

        .clue-section {
            width: 300px;  /* 固定宽度 */
            flex-shrink: 0;  /* 防止压缩 */
        }

        .clue-list {
            position: sticky;
            top: 20px;  /* 与顶部保持距离 */
            max-height: calc(100vh - 40px);  /* 减去上下margin */
            overflow-y: auto;  /* 内容过多时可滚动 */
        }

        /* 调整原有样式 */
        .puzzle-container {
            grid-template-columns: repeat(5, 1fr);
            gap: 10px;
        }

        .house {
            min-width: 0;  /* 防止内容溢出 */
        }

        /* 适配小屏幕 */
        @media (max-width: 1200px) {
            .main-container {
                flex-direction: column;
            }

            .clue-section {
                width: 100%;
            }

            .clue-list {
                position: static;
                max-height: none;
            }
        }

        .instructions {
            background-color: #fff3e0;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border-left: 4px solid #ff9800;
        }

        .undo-redo {
            display: flex;
            gap: 5px;
        }

        .undo-redo button {
            background-color: #607d8b;
            padding: 5px 10px;
        }

        .undo-redo button:disabled {
            background-color: #ccc;
        }

        .step-indicator {
            display: flex;
            justify-content: space-between;
            margin: 10px 0;
            padding: 10px;
            background-color: white;
            border-radius: 4px;
        }

        .step-count {
            font-weight: bold;
            color: #2196f3;
        }

        .hint-panel {
            background-color: #e8f5e9;
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            display: none;
        }

        .hint-panel.show {
            display: block;
        }

        /* 添加新的动画效果 */
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.02); }
            100% { transform: scale(1); }
        }

        .house.highlight-new {
            animation: pulse 0.5s ease;
            background-color: #e8f5e9;
        }

        .success-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .success-message {
            background: white;
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            animation: slideIn 0.5s ease;
        }

        @keyframes slideIn {
            from { transform: translateY(-100px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .solution-table {
            margin-top: 20px;
            border-collapse: collapse;
            width: 100%;
        }

        .solution-table th, .solution-table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }

        .solution-table th {
            background-color: #f5f5f5;
        }
    </style>
</head>
<body>
    <h1>爱因斯坦之谜求解演示</h1>
    
    <div class="instructions">
        <h3>操作说明：</h3>
        <ul>
            <li>点击"自动演示"可以观看完整解题过程</li>
            <li>点击"下一步"可以逐步查看解题过程</li>
            <li>使用下拉列表手动选择各个属性进行解题</li>
            <li>点击"提示"获取当前可能的选择</li>
            <li>使用撤销/重做按钮修正错误的选择</li>
        </ul>
    </div>

    <div class="controls">
        <div class="undo-redo">
            <button id="undo" title="撤销"><i>↩</i></button>
            <button id="redo" title="重做"><i>↪</i></button>
        </div>
        <button id="nextStep">下一步</button>
        <button id="autoSolve">自动演示</button>
        <button id="reset">重置</button>
        <button id="hint">提示</button>
    </div>

    <div class="step-indicator">
        <span>当前进度：</span>
        <span class="step-count"><span id="currentStep">0</span> / <span id="totalSteps">15</span></span>
    </div>

    <div class="hint-panel" id="hintPanel"></div>

    <div class="progress-bar">
        <div class="progress-fill" id="progressFill"></div>
    </div>
    <div class="status-message" id="statusMessage"></div>

    <div class="main-container">
        <div class="puzzle-section">
            <div class="puzzle-container" id="houses">
                <!-- 房子将通过JavaScript动态生成 -->
            </div>
        </div>
        <div class="clue-section">
            <div class="clue-list" id="clues">
                <!-- 线索将通过JavaScript动态生成 -->
            </div>
        </div>
    </div>

    <div class="success-overlay" id="successOverlay">
        <div class="success-message">
            <h2>恭喜！你解开了爱因斯坦之谜！</h2>
            <p id="solutionText"></p>
            <table class="solution-table" id="solutionTable"></table>
            <button onclick="hideSuccess()">关闭</button>
        </div>
    </div>

    <script>
        const houses = [
            { position: 1, color: null, nationality: null, drink: null, smoke: null, pet: null },
            { position: 2, color: null, nationality: null, drink: null, smoke: null, pet: null },
            { position: 3, color: null, nationality: null, drink: null, smoke: null, pet: null },
            { position: 4, color: null, nationality: null, drink: null, smoke: null, pet: null },
            { position: 5, color: null, nationality: null, drink: null, smoke: null, pet: null }
        ];

        let currentStep = 0;
        let autoSolveInterval = null;

        const OPTIONS = {
            color: ['红色', '蓝色', '绿色', '白色', '黄色'],
            nationality: ['挪威人', '英国人', '瑞典人', '丹麦人', '德国人'],
            drink: ['水', '茶', '牛奶', '咖啡', '啤酒'],
            smoke: ['Pall Mall', 'Dunhill', 'Blend', 'Blue Master', 'Prince'],
            pet: ['猫', '狗', '鸟', '马', '鱼']
        };

        const labels = {
            color: '颜色',
            nationality: '国籍',
            drink: '饮品',
            smoke: '香烟',
            pet: '宠物'
        };

        const clues = [
            { text: "1. 挪威人住第一间房子（初始条件）", apply: () => {
                houses[0].nationality = "挪威人";
                return "根据初始条件，挪威人住在第一间房子";
            }},
            { text: "2. 蓝色房子在第二个位置（初始条件）", apply: () => {
                houses[1].color = "蓝色";
                return "根据初始条件，第二间房子是蓝色的";
            }},
            { text: "3. 中间房子喝牛奶（初始条件）", apply: () => {
                houses[2].drink = "牛奶";
                return "根据初始条件，中间房子的人喝牛奶";
            }},
            { text: "4. 英国人住在红色房子里", apply: () => {
                const availableHouse = houses.find((h, index) => 
                    index !== 0 && h.nationality === null && h.color === null
                );
                if (availableHouse) {
                    availableHouse.nationality = "英国人";
                    availableHouse.color = "红色";
                    return "英国人住在红色房子里";
                }
                return "无法放置英国人和红色房子";
            }},
            { text: "5. 丹麦人喝茶", apply: () => {
                const availableHouse = houses.find(h => 
                    h.nationality === null && h.drink === null && 
                    h.color !== '绿色' // 绿色房子必须喝咖啡，所以丹麦人不能住在绿色房子里
                );
                if (availableHouse) {
                    availableHouse.nationality = "丹麦人";
                    availableHouse.drink = "茶";
                    return "丹麦人住在这里，喝茶";
                }
                return "无法安排丹麦人和茶";
            }},
            { text: "6. 绿色房子在白色房子的左边", apply: () => {
                for(let i = 0; i < 4; i++) {
                    if(houses[i].color === null && houses[i+1].color === null &&
                       houses[i].drink === null && // 确保绿色房子可以喝咖啡
                       (!houses[i].nationality || houses[i].nationality !== '丹麦人')) { // 确保不是丹麦人的房子
                        houses[i].color = "绿色";
                        houses[i+1].color = "白色";
                        return `绿色房子在第${i+1}位，白色房子在第${i+2}位`;
                    }
                }
                return "无法安排绿色和白色房子";
            }},
            { text: "7. 绿房子的主人喝咖啡", apply: () => {
                const greenHouse = houses.find(h => h.color === "绿色");
                if (greenHouse && greenHouse.drink === null) {
                    greenHouse.drink = "咖啡";
                    return "绿房子的主人喝咖啡";
                }
                return "无法安排咖啡";
            }},
            { text: "8. 抽Pall Mall香烟的人养鸟", apply: () => {
                const emptyHouse = houses.find(h => h.smoke === null && h.pet === null);
                emptyHouse.smoke = "Pall Mall";
                emptyHouse.pet = "鸟";
                return "找到抽Pall Mall香烟的人，他养鸟";
            }},
            { text: "9. 黄色房子的主人抽Dunhill香烟", apply: () => {
                const emptyHouse = houses.find(h => h.color === null);
                emptyHouse.color = "黄色";
                emptyHouse.smoke = "Dunhill";
                return "黄色房子的主人抽Dunhill香烟";
            }},
            { text: "10. 抽Blend香烟的人住在养猫的人旁边", apply: () => {
                for(let i = 0; i < 4; i++) {
                    if(houses[i].smoke === null && houses[i+1].pet === null) {
                        houses[i].smoke = "Blend";
                        houses[i+1].pet = "猫";
                        return `第${i+1}房子的人抽Blend烟，旁边的人养猫`;
                    }
                }
            }},
            { text: "11. 养马的人住在抽Dunhill烟的人旁边", apply: () => {
                const dunhillHouse = houses.find(h => h.smoke === "Dunhill");
                const index = houses.indexOf(dunhillHouse);
                if(index > 0 && houses[index-1].pet === null) {
                    houses[index-1].pet = "马";
                    return `在Dunhill烟者左边的人养马`;
                } else {
                    houses[index+1].pet = "马";
                    return `在Dunhill烟者右边的人养马`;
                }
            }},
            { text: "12. 抽Blue Master烟的人喝啤酒", apply: () => {
                const emptyHouse = houses.find(h => h.smoke === null && h.drink === null);
                emptyHouse.smoke = "Blue Master";
                emptyHouse.drink = "啤酒";
                return "抽Blue Master烟的人喝啤酒";
            }},
            { text: "13. 德国人抽Prince香烟", apply: () => {
                const emptyHouse = houses.find(h => h.nationality === null);
                emptyHouse.nationality = "德国人";
                emptyHouse.smoke = "Prince";
                return "德国人抽Prince香烟";
            }},
            { text: "14. 抽Blend烟的人住在喝水的人旁边", apply: () => {
                const blendHouse = houses.find(h => h.smoke === "Blend");
                const index = houses.indexOf(blendHouse);
                if(index > 0 && houses[index-1].drink === null) {
                    houses[index-1].drink = "水";
                    return "Blend烟者左边的人喝水";
                } else {
                    houses[index+1].drink = "水";
                    return "Blend烟者右边的人喝水";
                }
            }},
            { text: "15. 最终问题：谁养鱼？", apply: () => {
                const fishOwner = houses.find(h => h.pet === null);
                fishOwner.pet = "鱼";
                return `解谜完成！${fishOwner.nationality}养鱼。`;
            }}
        ];

        // 历史记录管理
        const history = {
            past: [],          // 过去的状态
            future: [],        // 将来的状态（用于重做）
            maxSteps: 100,     // 最大记录步数
            currentState: null // 当前状态
        };

        function saveState() {
            const state = {
                houses: JSON.parse(JSON.stringify(houses)),
                currentStep: currentStep
            };
            
            // 如果有当前状态，将其保存到历史记录中
            if (history.currentState) {
                history.past.push(history.currentState);
            }
            
            // 限制历史记录长度
            while (history.past.length > history.maxSteps) {
                history.past.shift();
            }
            
            history.currentState = state;
            history.future = [];  // 清空重做记录
            
            updateUndoRedoButtons();
            saveToLocalStorage();
        }

        function undo() {
            if (history.past.length > 0) {
                // 将当前状态保存到future
                history.future.push(history.currentState);
                
                // 获取上一个状态
                const previousState = history.past.pop();
                history.currentState = previousState;
                
                // 深拷贝恢复状态
                houses.length = 0; // 清空当前数组
                previousState.houses.forEach(house => {
                    houses.push(JSON.parse(JSON.stringify(house)));
                });
                currentStep = previousState.currentStep;
                
                // 更新界面
                renderHouses();
                renderClues();
                updateProgress();
                updateUndoRedoButtons();
                saveToLocalStorage();

                // 显示状态消息
                showStatusMessage('已撤销上一步操作', 'success', true);
            }
        }

        function redo() {
            if (history.future.length > 0) {
                // 保存当前状态到past
                history.past.push(history.currentState);
                
                // 获取下一个状态
                const nextState = history.future.pop();
                history.currentState = nextState;
                
                // 深拷贝恢复状态
                houses.length = 0;
                nextState.houses.forEach(house => {
                    houses.push(JSON.parse(JSON.stringify(house)));
                });
                currentStep = nextState.currentStep;
                
                // 更新界面
                renderHouses();
                renderClues();
                updateProgress();
                updateUndoRedoButtons();
                saveToLocalStorage();

                // 显示状态消息
                showStatusMessage('已重做操作', 'success', true);
            }
        }

        function updateUndoRedoButtons() {
            const undoBtn = document.getElementById('undo');
            const redoBtn = document.getElementById('redo');
            
            undoBtn.disabled = history.past.length === 0;
            redoBtn.disabled = history.future.length === 0;
            
            // 添加更详细的提示信息
            undoBtn.title = history.past.length > 0 ? 
                `撤销 (还可撤销${history.past.length}步)` : 
                '没有可撤销的操作';
            
            redoBtn.title = history.future.length > 0 ? 
                `重做 (还可重做${history.future.length}步)` : 
                '没有可重做的操作';
        }

        function saveToLocalStorage() {
            localStorage.setItem('einsteinPuzzleState', JSON.stringify({
                currentState: history.currentState,
                past: history.past,
                future: history.future
            }));
        }

        function loadFromLocalStorage() {
            const saved = localStorage.getItem('einsteinPuzzleState');
            if (saved) {
                const state = JSON.parse(saved);
                history.currentState = state.currentState;
                history.past = state.past || [];
                history.future = state.future || [];
                
                if (history.currentState) {
                    houses.splice(0, houses.length, ...history.currentState.houses);
                    currentStep = history.currentState.currentStep;
                    renderHouses();
                    renderClues();
                    updateProgress();
                }
                
                updateUndoRedoButtons();
            }
        }

        function renderHouses() {
            const container = document.getElementById('houses');
            container.innerHTML = '';
            
            houses.forEach((house, index) => {
                const houseDiv = document.createElement('div');
                houseDiv.className = 'house';
                
                const properties = ['color', 'nationality', 'drink', 'smoke', 'pet'];
                const labels = {
                    color: '颜色',
                    nationality: '国籍',
                    drink: '饮品',
                    smoke: '香烟',
                    pet: '宠物'
                };

                let html = `<h3>房子 ${index + 1}</h3>`;
                
                properties.forEach(prop => {
                    const isConfirmed = house[prop] !== null;
                    html += `
                        <div class="property ${isConfirmed ? 'confirmed' : ''}">
                            <label>${labels[prop]}</label>
                            <select data-house="${index}" data-prop="${prop}" ${isConfirmed ? 'disabled' : ''}>
                                <option value="">-- 请选择 --</option>
                                ${OPTIONS[prop].map(option => 
                                    `<option value="${option}" ${house[prop] === option ? 'selected' : ''}>${option}</option>`
                                ).join('')}
                            </select>
                        </div>
                    `;
                });

                houseDiv.innerHTML = html;
                container.appendChild(houseDiv);
            });

            // 添加选择事件监听
            document.querySelectorAll('.property select').forEach(select => {
                select.addEventListener('change', (e) => {
                    const houseIndex = parseInt(e.target.dataset.house);
                    const prop = e.target.dataset.prop;
                    const value = e.target.value;

                    if (value) {
                        // 使用handleSelection函数处理选择
                        if (!handleSelection(houseIndex, prop, value)) {
                            e.target.value = ''; // 重置选择
                        }
                    }
                });
            });

            updateProgress();
            updateStepIndicator();
        }

        function renderClues() {
            const container = document.getElementById('clues');
            container.innerHTML = '';
            
            clues.forEach((clue, index) => {
                const clueDiv = document.createElement('div');
                clueDiv.className = `clue ${index === currentStep ? 'active' : ''}`;
                clueDiv.textContent = clue.text;
                container.appendChild(clueDiv);
            });
        }

        function nextStep() {
            if (currentStep < clues.length) {
                // 保存当前状态
                saveState();
                
                // 获取当前线索并执行
                const clue = clues[currentStep];
                const explanation = clue.apply();
                
                // 高亮显示相关房子
                const houses = document.querySelectorAll('.house');
                houses.forEach(house => house.classList.remove('highlight'));
                
                // 添加解释文本，包含推理过程
                const activeClue = document.querySelectorAll('.clue')[currentStep];
                const explanationDiv = document.createElement('div');
                explanationDiv.className = 'explanation';
                
                // 根据不同线索提供详细的推理说明
                let detailedExplanation = '';
                switch (currentStep) {
                    case 0:
                        detailedExplanation = "根据初始条件，挪威人必须住在第一间房子。这是问题的基本条件之一。";
                        break;
                    case 1:
                        detailedExplanation = "根据初始条件，第二间房子必须是蓝色的。这是问题的基本条件之一。";
                        break;
                    case 2:
                        detailedExplanation = "根据初始条件，中间房子（第三间）的人喝牛奶。这是问题的基本条件之一。";
                        break;
                    case 3:
                        detailedExplanation = "根据线索，英国人住在红色房子里。注意：由于第一间房子已经住了挪威人，所以英国人不能住在第一间房子。";
                        break;
                    case 4:
                        detailedExplanation = "根据线索，丹麦人喝茶。需要找到一个还没有确定国籍和饮品的房子。";
                        break;
                    case 5:
                        detailedExplanation = "根据线索，绿色房子必须在白色房子的左边。这意味着绿色房子不能在最后一个位置，白色房子不能在第一个位置。";
                        break;
                    case 6:
                        detailedExplanation = "根据线索，绿房子的主人喝咖啡。找到绿色房子并确定其饮品为咖啡。";
                        break;
                    case 7:
                        detailedExplanation = "根据线索，抽Pall Mall香烟的人养鸟。需要找到一个还没有确定香烟和宠物的房子。";
                        break;
                    case 8:
                        detailedExplanation = "根据线索，黄色房子的主人抽Dunhill香烟。需要找到一个还没有确定颜色和香烟的房子。";
                        break;
                    case 9:
                        detailedExplanation = "根据线索，抽Blend香烟的人住在养猫的人旁边。这是一个相邻关系的约束。";
                        break;
                    case 10:
                        detailedExplanation = "根据线索，养马的人住在抽Dunhill烟的人旁边。找到抽Dunhill烟的房子，然后在其相邻位置安排养马的人。";
                        break;
                    case 11:
                        detailedExplanation = "根据线索，抽Blue Master烟的人喝啤酒。需要找到一个还没有确定香烟和饮品的房子。";
                        break;
                    case 12:
                        detailedExplanation = "根据线索，德国人抽Prince香烟。需要找到最后一个还没有确定国籍的房子。";
                        break;
                    case 13:
                        detailedExplanation = "根据线索，抽Blend烟的人住在喝水的人旁边。找到抽Blend烟的房子，然后在其相邻位置安排喝水的人。";
                        break;
                    case 14:
                        detailedExplanation = "最后一步：找到还没有确定宠物的房子，那个人一定养鱼。";
                        break;
                }
                
                explanationDiv.textContent = detailedExplanation;
                activeClue.appendChild(explanationDiv);

                currentStep++;
                renderHouses();
                renderClues();
                
                // 显示状态消息，不自动隐藏
                showStatusMessage(`执行第 ${currentStep} 步：${detailedExplanation}`, 'success', false);
            }
        }

        function autoSolve() {
            if (autoSolveInterval) {
                clearInterval(autoSolveInterval);
                autoSolveInterval = null;
                document.getElementById('autoSolve').textContent = '自动演示';
            } else {
                reset();
                document.getElementById('autoSolve').textContent = '暂停';
                
                autoSolveInterval = setInterval(() => {
                    if (currentStep < clues.length) {
                        // 保存当前状态
                        const oldState = {
                            houses: JSON.parse(JSON.stringify(houses)),
                            currentStep: currentStep,
                            timestamp: Date.now(),
                            description: `执行步骤 ${currentStep + 1}: ${clues[currentStep].text}`
                        };

                        // 执行当前步骤
                        const explanation = clues[currentStep].apply();
                        currentStep++;

                        // 保存新状态到历史记录
                        saveAutoStepToHistory(oldState, explanation);
                        
                        // 更新界面
                        renderHouses();
                        renderClues();
                        updateProgress();
                        
                        // 检查是否完成所有线索
                        if (currentStep >= clues.length) {
                            // 检查是否所有属性都已填写
                            const isAllFilled = houses.every(house => 
                                Object.entries(house).every(([key, value]) => 
                                    key === 'position' || value !== null
                                )
                            );
                            
                            if (!isAllFilled) {
                                // 如果还有未填写的属性，继续填充
                                fillRemainingProperties();
                            } else {
                                finishAutoSolve();
                            }
                        }
                    }
                }, 1000);
            }
        }

        function fillRemainingProperties() {
            let changed = false;
            
            // 首先检查是否还有未填写的属性
            const hasEmptyProperties = houses.some(house => 
                Object.entries(house).some(([key, value]) => 
                    key !== 'position' && value === null
                )
            );

            if (!hasEmptyProperties) {
                finishAutoSolve();
                return;
            }

            // 获取所有已使用的值
            const usedValues = {
                nationality: houses.map(h => h.nationality).filter(v => v !== null),
                color: houses.map(h => h.color).filter(v => v !== null),
                drink: houses.map(h => h.drink).filter(v => v !== null),
                smoke: houses.map(h => h.smoke).filter(v => v !== null),
                pet: houses.map(h => h.pet).filter(v => v !== null)
            };

            // 获取每个属性的剩余可用值
            const remainingValues = {
                nationality: OPTIONS.nationality.filter(v => !usedValues.nationality.includes(v)),
                color: OPTIONS.color.filter(v => !usedValues.color.includes(v)),
                drink: OPTIONS.drink.filter(v => !usedValues.drink.includes(v)),
                smoke: OPTIONS.smoke.filter(v => !usedValues.smoke.includes(v)),
                pet: OPTIONS.pet.filter(v => !usedValues.pet.includes(v))
            };

            // 修改属性填充顺序，确保先处理关键约束
            const propertyOrder = ['nationality', 'color', 'drink', 'smoke', 'pet'];
            
            for (let houseIndex = 0; houseIndex < houses.length; houseIndex++) {
                const house = houses[houseIndex];
                
                for (const prop of propertyOrder) {
                    if (house[prop] === null) {
                        // 确保第一间房子的特殊处理
                        if (houseIndex === 0 && prop === 'nationality' && house.nationality === null) {
                            house.nationality = '挪威人';
                            continue;
                        }
                        
                        // 尝试剩余的值
                        for (const value of remainingValues[prop]) {
                            if (isValidSelection(houseIndex, prop, value)) {
                                // 保存当前状态
                                const oldState = {
                                    houses: JSON.parse(JSON.stringify(houses)),
                                    currentStep: currentStep,
                                    description: `自动填充：第${houseIndex + 1}号房子的${labels[prop]}设为${value}`
                                };
                                
                                // 应用选择
                                house[prop] = value;
                                changed = true;
                                
                                // 从剩余值中移除已使用的值
                                remainingValues[prop] = remainingValues[prop].filter(v => v !== value);
                                
                                // 保存到历史记录
                                saveAutoStepToHistory(oldState, `根据约束条件推导，第${houseIndex + 1}号房子的${labels[prop]}是${value}`);
                                
                                // 更新界面
                                renderHouses();
                                renderClues();
                                updateProgress();
                                break;
                            }
                        }
                    }
                }
            }
            
            // 如果有变化，继续填充
            if (changed) {
                setTimeout(fillRemainingProperties, 1000);
            } else {
                // 如果没有变化但仍有空值，可能需要回溯
                const hasNull = houses.some(house => 
                    Object.values(house).some(value => value === null)
                );
                
                if (hasNull) {
                    // 尝试使用未使用的值填充剩余空位
                    houses.forEach((house, index) => {
                        Object.keys(house).forEach(prop => {
                            if (prop !== 'position' && house[prop] === null) {
                                const unusedValue = remainingValues[prop][0];
                                if (unusedValue) {
                                    house[prop] = unusedValue;
                                    remainingValues[prop].shift();
                                    changed = true;
                                }
                            }
                        });
                    });
                    
                    if (changed) {
                        setTimeout(fillRemainingProperties, 1000);
                    } else {
                        finishAutoSolve();
                    }
                } else {
                    finishAutoSolve();
                }
            }
        }

        function isValidSelection(houseIndex, prop, value) {
            // 检查是否已经在其他房子中使用
            if (houses.some((h, i) => i !== houseIndex && h[prop] === value)) {
                return false;
            }
            
            const house = houses[houseIndex];
            
            // 1. 严格检查初始条件
            if (houseIndex === 0) {
                if (prop === 'nationality' && value !== '挪威人') return false;
                if (prop === 'color' && value === '红色') return false; // 第一间房子不能是红色（因为英国人住红色房子）
            }
            if (houseIndex === 1 && prop === 'color' && value !== '蓝色') return false;
            if (houseIndex === 2 && prop === 'drink' && value !== '牛奶') return false;
            
            // 2. 检查英国人和红色房子的关系
            if (prop === 'nationality' && value === '英国人' && house.color !== null && house.color !== '红色') return false;
            if (prop === 'color' && value === '红色' && house.nationality !== null && house.nationality !== '英国人') return false;
            if (prop === 'nationality' && value === '英国人' && houseIndex === 0) return false; // 英国人不能住第一间房子
            if (prop === 'color' && value === '红色' && houseIndex === 0) return false; // 第一间房子不能是红色

            // 3. 检查相邻规则
            // 绿色房子在白色房子的左边
            if (prop === 'color') {
                if (value === '绿色') {
                    if (houseIndex === 4) return false; // 绿色不能在最后一个位置
                    const nextHouse = houses[houseIndex + 1];
                    if (nextHouse.color !== null && nextHouse.color !== '白色') return false;
                }
                if (value === '白色') {
                    if (houseIndex === 0) return false; // 白色不能在第一个位置
                    const prevHouse = houses[houseIndex - 1];
                    if (prevHouse.color !== null && prevHouse.color !== '绿色') return false;
                }
            }

            // 4. 检查相邻约束
            const neighbors = [];
            if (houseIndex > 0) neighbors.push(houses[houseIndex - 1]);
            if (houseIndex < 4) neighbors.push(houses[houseIndex + 1]);

            // Blend烟和猫必须相邻
            if (prop === 'smoke' && value === 'Blend') {
                const hasCatNeighbor = neighbors.some(h => h.pet === '猫' || h.pet === null);
                if (!hasCatNeighbor) return false;
            }
            if (prop === 'pet' && value === '猫') {
                const hasBlendNeighbor = neighbors.some(h => h.smoke === 'Blend' || h.smoke === null);
                if (!hasBlendNeighbor) return false;
            }

            // Dunhill烟和马必须相邻
            if (prop === 'smoke' && value === 'Dunhill') {
                const hasHorseNeighbor = neighbors.some(h => h.pet === '马' || h.pet === null);
                if (!hasHorseNeighbor) return false;
            }
            if (prop === 'pet' && value === '马') {
                const hasDunhillNeighbor = neighbors.some(h => h.smoke === 'Dunhill' || h.smoke === null);
                if (!hasDunhillNeighbor) return false;
            }

            // Blend烟和水必须相邻
            if (prop === 'smoke' && value === 'Blend') {
                const hasWaterNeighbor = neighbors.some(h => h.drink === '水' || h.drink === null);
                if (!hasWaterNeighbor) return false;
            }
            if (prop === 'drink' && value === '水') {
                const hasBlendNeighbor = neighbors.some(h => h.smoke === 'Blend' || h.smoke === null);
                if (!hasBlendNeighbor) return false;
            }

            // 5. 检查属性关联
            const relations = [
                { prop1: 'nationality', value1: '英国人', prop2: 'color', value2: '红色' },
                { prop1: 'nationality', value1: '瑞典人', prop2: 'pet', value2: '狗' },
                { prop1: 'nationality', value1: '丹麦人', prop2: 'drink', value2: '茶' },
                { prop1: 'color', value1: '绿色', prop2: 'drink', value2: '咖啡' },
                { prop1: 'color', value1: '黄色', prop2: 'smoke', value2: 'Dunhill' },
                { prop1: 'smoke', value1: 'Pall Mall', prop2: 'pet', value2: '鸟' },
                { prop1: 'smoke', value1: 'Blue Master', prop2: 'drink', value2: '啤酒' },
                { prop1: 'nationality', value1: '德国人', prop2: 'smoke', value2: 'Prince' }
            ];

            for (const relation of relations) {
                if (prop === relation.prop1 && value === relation.value1) {
                    if (house[relation.prop2] !== null && house[relation.prop2] !== relation.value2) return false;
                }
                if (prop === relation.prop2 && value === relation.value2) {
                    if (house[relation.prop1] !== null && house[relation.prop1] !== relation.value1) return false;
                }
            }

            // 添加丹麦人和茶的关联验证
            if (prop === 'nationality' && value === '丹麦人') {
                if (house.drink !== null && house.drink !== '茶') return false;
                if (house.color === '绿色') return false; // 丹麦人不能住在绿色房子里（因为绿色房子喝咖啡）
            }
            if (prop === 'drink' && value === '茶') {
                if (house.nationality !== null && house.nationality !== '丹麦人') return false;
            }
            if (prop === 'drink' && value === '咖啡') {
                if (house.color !== null && house.color !== '绿色') return false;
                if (house.nationality === '丹麦人') return false; // 丹麦人不能喝咖啡
            }
            if (prop === 'color' && value === '绿色') {
                if (house.drink !== null && house.drink !== '咖啡') return false;
                if (house.nationality === '丹麦人') return false; // 绿色房子不能是丹麦人的
            }

            // 6. 检查是否会导致其他位置无解
            const tempHouses = JSON.parse(JSON.stringify(houses));
            tempHouses[houseIndex][prop] = value;

            // 检查每个未填写的位置是否还有可能的值
            for (let i = 0; i < houses.length; i++) {
                for (const p of ['nationality', 'color', 'drink', 'smoke', 'pet']) {
                    if (tempHouses[i][p] === null) {
                        let hasValidOption = false;
                        for (const option of OPTIONS[p]) {
                            if (!houses.some((h, idx) => idx !== i && h[p] === option)) {
                                hasValidOption = true;
                                break;
                            }
                        }
                        if (!hasValidOption) return false;
                    }
                }
            }

            // 添加新的约束条件
            if (prop === 'smoke' && value === 'Blend') {
                const neighbors = getNeighbors(houseIndex);
                const hasWaterNeighbor = neighbors.some(h => h.drink === '水' || h.drink === null);
                if (!hasWaterNeighbor) return false;
            }
            if (prop === 'drink' && value === '水') {
                const neighbors = getNeighbors(houseIndex);
                const hasBlendNeighbor = neighbors.some(h => h.smoke === 'Blend' || h.smoke === null);
                if (!hasBlendNeighbor) return false;
            }

            // Blue Master烟和啤酒的关系
            if (prop === 'smoke' && value === 'Blue Master' && house.drink !== null && house.drink !== '啤酒') return false;
            if (prop === 'drink' && value === '啤酒' && house.smoke !== null && house.smoke !== 'Blue Master') return false;

            return true;
        }

        function getNeighbors(houseIndex) {
            const neighbors = [];
            if (houseIndex > 0) neighbors.push(houses[houseIndex - 1]);
            if (houseIndex < houses.length - 1) neighbors.push(houses[houseIndex + 1]);
            return neighbors;
        }

        function saveAutoStepToHistory(oldState, explanation) {
            const newState = {
                houses: JSON.parse(JSON.stringify(houses)),
                currentStep: currentStep,
                timestamp: Date.now(),
                description: oldState.description,
                explanation: explanation
            };

            // 保存到历史记录
            if (history.currentState) {
                history.past.push(history.currentState);
            }
            
            // 如果超过最大步数，删除最早的记录
            while (history.past.length >= history.maxSteps) {
                history.past.shift();
            }
            
            history.currentState = newState;
            history.future = []; // 清空重做栈
            
            updateUndoRedoButtons();
            saveToLocalStorage();
        }

        function finishAutoSolve() {
            clearInterval(autoSolveInterval);
            autoSolveInterval = null;
            document.getElementById('autoSolve').textContent = '自动演示';
            showSuccess();
        }

        function showSuccess() {
            const overlay = document.getElementById('successOverlay');
            const table = document.getElementById('solutionTable');
            
            // 创建解答表格
            let html = `
                <tr>
                    <th>房子</th>
                    <th>颜色</th>
                    <th>国籍</th>
                    <th>饮品</th>
                    <th>香烟</th>
                    <th>宠物</th>
                </tr>
            `;

            houses.forEach((house, index) => {
                html += `
                    <tr>
                        <td>${index + 1}</td>
                        <td>${house.color}</td>
                        <td>${house.nationality}</td>
                        <td>${house.drink}</td>
                        <td>${house.smoke}</td>
                        <td>${house.pet}</td>
                    </tr>
                `;
            });

            table.innerHTML = html;
            
            const fishOwner = houses.find(h => h.pet === '鱼');
            document.getElementById('solutionText').textContent = 
                `解谜完成！${fishOwner.nationality}养鱼。`;

            overlay.style.display = 'flex';
        }

        function hideSuccess() {
            document.getElementById('successOverlay').style.display = 'none';
        }

        function handleSelection(houseIndex, prop, value) {
            const validationResult = validateSelection(houseIndex, prop, value);
            if (!validationResult.isValid) {
                showStatusMessage(validationResult.message || '选择无效，请重试', 'error', true);
                return false;
            }

            // 保存当前状态（只保存一次）
            saveState();
            
            // 应用新的选择
            houses[houseIndex][prop] = value;
            
            // 添加高亮动画
            const houseDiv = document.querySelectorAll('.house')[houseIndex];
            houseDiv.classList.add('highlight-new');
            setTimeout(() => {
                houseDiv.classList.remove('highlight-new');
            }, 500);

            // 更新UI
            renderHouses();
            checkCompletion();
            return true;
        }

        function validateSelection(houseIndex, prop, value) {
            // 检查是否已经在其他房子中使用
            if (houses.some((h, i) => i !== houseIndex && h[prop] === value)) {
                return {
                    isValid: false,
                    message: `${labels[prop]} "${value}" 已经被其他房子使用了`
                };
            }
            
            const house = houses[houseIndex];
            
            // 1. 检查初始条件
            if (houseIndex === 0 && prop === 'nationality' && value !== '挪威人') 
                return { isValid: false, message: '第一间房子必须住挪威人' };
            if (houseIndex === 1 && prop === 'color' && value !== '蓝色')
                return { isValid: false, message: '第二间房子必须是蓝色的' };
            if (houseIndex === 2 && prop === 'drink' && value !== '牛奶')
                return { isValid: false, message: '中间房子必须喝牛奶' };
            
            // 2. 检查相邻规则
            if (prop === 'color') {
                if (value === '绿色') {
                    if (houseIndex === 4) 
                        return { isValid: false, message: '绿色房子不能在最后一个位置' };
                    const nextHouse = houses[houseIndex + 1];
                    if (nextHouse.color !== null && nextHouse.color !== '白色') 
                        return { isValid: false, message: '绿色房子必须在白色房子的左边' };
                }
                if (value === '白色') {
                    if (houseIndex === 0) 
                        return { isValid: false, message: '白色房子不能在第一个位置' };
                    const prevHouse = houses[houseIndex - 1];
                    if (prevHouse.color !== null && prevHouse.color !== '绿色') 
                        return { isValid: false, message: '白色房子必须在绿色房子的右边' };
                }
            }

            // 3. 检查相邻约束和属性关联
            // ... 其他验证代码保持不变 ...

            // 4. 检查属性关联
            const relations = [
                { prop1: 'nationality', value1: '英国人', prop2: 'color', value2: '红色', message: '英国人必须住在红色房子里' },
                { prop1: 'nationality', value1: '瑞典人', prop2: 'pet', value2: '狗', message: '瑞典人必须养狗' },
                { prop1: 'nationality', value1: '丹麦人', prop2: 'drink', value2: '茶', message: '丹麦人必须喝茶' },
                { prop1: 'color', value1: '绿色', prop2: 'drink', value2: '咖啡', message: '绿房子的主人必须喝咖啡' },
                { prop1: 'color', value1: '黄色', prop2: 'smoke', value2: 'Dunhill', message: '黄色房子的主人必须抽Dunhill香烟' },
                { prop1: 'smoke', value1: 'Pall Mall', prop2: 'pet', value2: '鸟', message: '抽Pall Mall香烟的人必须养鸟' },
                { prop1: 'smoke', value1: 'Blue Master', prop2: 'drink', value2: '啤酒', message: '抽Blue Master烟的人必须喝啤酒' },
                { prop1: 'nationality', value1: '德国人', prop2: 'smoke', value2: 'Prince', message: '德国人必须抽Prince香烟' }
            ];

            for (const relation of relations) {
                if (prop === relation.prop1 && value === relation.value1) {
                    if (house[relation.prop2] !== null && house[relation.prop2] !== relation.value2) 
                        return { isValid: false, message: relation.message };
                }
                if (prop === relation.prop2 && value === relation.value2) {
                    if (house[relation.prop1] !== null && house[relation.prop1] !== relation.value1) 
                        return { isValid: false, message: relation.message };
                }
            }

            // 添加丹麦人和茶的关联验证
            if (prop === 'nationality' && value === '丹麦人') {
                if (house.drink !== null && house.drink !== '茶') return false;
                if (house.color === '绿色') return false; // 丹麦人不能住在绿色房子里（因为绿色房子喝咖啡）
            }
            if (prop === 'drink' && value === '茶') {
                if (house.nationality !== null && house.nationality !== '丹麦人') return false;
            }
            if (prop === 'drink' && value === '咖啡') {
                if (house.color !== null && house.color !== '绿色') return false;
                if (house.nationality === '丹麦人') return false; // 丹麦人不能喝咖啡
            }
            if (prop === 'color' && value === '绿色') {
                if (house.drink !== null && house.drink !== '咖啡') return false;
                if (house.nationality === '丹麦人') return false; // 绿色房子不能是丹麦人的
            }

            return { isValid: true };
        }

        function checkCompletion() {
            const isComplete = houses.every(house => 
                Object.entries(house).every(([key, value]) => key === 'position' || value !== null)
            );

            if (isComplete) {
                showSuccess();
            }
        }

        function updateProgress() {
            const totalProperties = houses.length * 5; // 5 properties per house
            const filledProperties = houses.reduce((count, house) => {
                return count + Object.values(house).filter(value => value !== null).length - 1; // -1 for position
            }, 0);
            
            const progress = (filledProperties / totalProperties) * 100;
            document.getElementById('progressFill').style.width = `${progress}%`;
        }

        function showStatusMessage(message, type, autoHide = false) {
            const statusDiv = document.getElementById('statusMessage');
            statusDiv.textContent = message;
            statusDiv.className = `status-message ${type}`;
            
            // 只有当autoHide为true时才自动隐藏
            if (autoHide) {
                if (window.statusTimeout) {
                    clearTimeout(window.statusTimeout);
                }
                
                window.statusTimeout = setTimeout(() => {
                    statusDiv.className = 'status-message';
                }, 3000);
            }
        }

        // 更新进度显示
        function updateStepIndicator() {
            document.getElementById('currentStep').textContent = currentStep;
            document.getElementById('totalSteps').textContent = clues.length;
        }

        // 修改reset函数
        function reset() {
            currentStep = 0;
            houses.forEach(house => {
                house.color = null;
                house.nationality = null;
                house.drink = null;
                house.smoke = null;
                house.pet = null;
            });
            
            // 清空历史记录
            history.past = [];
            history.future = [];
            history.currentState = null;
            
            // 重新渲染界面
            renderHouses();
            renderClues();
            updateProgress();
            updateStepIndicator();
            updateUndoRedoButtons();
        }

        // 修改初始化部分
        function initializeGame() {
            // 初始渲染
            renderHouses();
            renderClues();
            updateProgress();
            updateStepIndicator();
            updateUndoRedoButtons();
        }

        // 修改事件监听和初始化部分
        document.addEventListener('DOMContentLoaded', function() {
            // 初始化事件监听
            document.getElementById('nextStep').addEventListener('click', nextStep);
            document.getElementById('autoSolve').addEventListener('click', autoSolve);
            document.getElementById('reset').addEventListener('click', reset);
            document.getElementById('hint').addEventListener('click', showHint);
            document.getElementById('undo').addEventListener('click', undo);
            document.getElementById('redo').addEventListener('click', redo);
            
            // 尝试加载保存的状态
            const savedState = localStorage.getItem('einsteinPuzzleState');
            if (savedState) {
                loadFromLocalStorage();
            } else {
                // 如果没有保存的状态，初始化新游戏
                initializeGame();
            }
        });

        // 立即调用初始化
        initializeGame();
    </script>
</body>
</html>

